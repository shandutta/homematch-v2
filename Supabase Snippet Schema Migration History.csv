version,statements,name,created_by,idempotency_key
20250728013631,"[""-- HomeMatch V2 Database Schema Migration\n-- Step 2.2: Complete database setup with PostGIS support\n\n-- Enable required extensions\nCREATE EXTENSION IF NOT EXISTS \""uuid-ossp\"";\nCREATE EXTENSION IF NOT EXISTS \""postgis\"";""]",setup_homematch_v2_schema,shankhayan.dutta@gmail.com,null
20250728013640,"[""-- User profiles (extends auth.users)\nCREATE TABLE IF NOT EXISTS user_profiles (\n  id UUID REFERENCES auth.users(id) PRIMARY KEY,\n  household_id UUID,\n  onboarding_completed BOOLEAN DEFAULT FALSE,\n  preferences JSONB DEFAULT '{}',\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Households for collaboration\nCREATE TABLE IF NOT EXISTS households (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  name TEXT NOT NULL,\n  collaboration_mode TEXT DEFAULT 'independent' CHECK (collaboration_mode IN ('independent', 'shared', 'weighted')),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Add foreign key constraint for user_profiles.household_id\nALTER TABLE user_profiles \nADD CONSTRAINT fk_user_profiles_household \nFOREIGN KEY (household_id) REFERENCES households(id);""]",create_core_tables,shankhayan.dutta@gmail.com,null
20250728013645,"[""-- Neighborhoods (simplified from V1's 4-table hierarchy)\nCREATE TABLE IF NOT EXISTS neighborhoods (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  name TEXT NOT NULL,\n  city TEXT NOT NULL,\n  state TEXT NOT NULL,\n  metro_area TEXT,\n  bounds POLYGON,\n  median_price INTEGER,\n  walk_score INTEGER,\n  transit_score INTEGER,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);""]",create_neighborhoods_table,shankhayan.dutta@gmail.com,null
20250728013652,"[""-- Properties\nCREATE TABLE IF NOT EXISTS properties (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  zpid TEXT UNIQUE, -- Zillow integration\n  address TEXT NOT NULL,\n  city TEXT NOT NULL,\n  state TEXT NOT NULL,\n  zip_code TEXT NOT NULL,\n  price INTEGER NOT NULL,\n  bedrooms INTEGER NOT NULL,\n  bathrooms DECIMAL(2,1) NOT NULL,\n  square_feet INTEGER,\n  property_type TEXT CHECK (property_type IN ('house', 'condo', 'townhouse', 'apartment')),\n  images TEXT[] DEFAULT '{}',\n  description TEXT,\n  coordinates POINT,\n  neighborhood_id UUID REFERENCES neighborhoods(id),\n  amenities TEXT[] DEFAULT '{}',\n  year_built INTEGER,\n  lot_size_sqft INTEGER,\n  parking_spots INTEGER DEFAULT 0,\n  listing_status TEXT DEFAULT 'active',\n  property_hash TEXT UNIQUE, -- For deduplication\n  is_active BOOLEAN DEFAULT TRUE,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);""]",create_properties_table,shankhayan.dutta@gmail.com,null
20250728013659,"[""-- User property interactions\nCREATE TABLE IF NOT EXISTS user_property_interactions (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID REFERENCES auth.users(id) NOT NULL,\n  property_id UUID REFERENCES properties(id) NOT NULL,\n  household_id UUID REFERENCES households(id),\n  interaction_type TEXT CHECK (interaction_type IN ('like', 'dislike', 'skip', 'view')) NOT NULL,\n  score_data JSONB, -- Store ML scores with interaction\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  UNIQUE(user_id, property_id, interaction_type)\n);\n\n-- Saved searches\nCREATE TABLE IF NOT EXISTS saved_searches (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID REFERENCES auth.users(id) NOT NULL,\n  household_id UUID REFERENCES households(id),\n  name TEXT NOT NULL,\n  filters JSONB NOT NULL,\n  is_active BOOLEAN DEFAULT TRUE,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);""]",create_interaction_tables,shankhayan.dutta@gmail.com,null
20250728013707,"[""-- Indexes for performance optimization\nCREATE INDEX IF NOT EXISTS idx_properties_coordinates ON properties USING GIST (coordinates);\nCREATE INDEX IF NOT EXISTS idx_properties_neighborhood_id ON properties(neighborhood_id);\nCREATE INDEX IF NOT EXISTS idx_properties_price ON properties(price);\nCREATE INDEX IF NOT EXISTS idx_properties_bedrooms ON properties(bedrooms);\nCREATE INDEX IF NOT EXISTS idx_properties_bathrooms ON properties(bathrooms);\nCREATE INDEX IF NOT EXISTS idx_properties_square_feet ON properties(square_feet);\nCREATE INDEX IF NOT EXISTS idx_properties_property_type ON properties(property_type);\nCREATE INDEX IF NOT EXISTS idx_properties_listing_status ON properties(listing_status);\nCREATE INDEX IF NOT EXISTS idx_properties_is_active ON properties(is_active);\n\nCREATE INDEX IF NOT EXISTS idx_neighborhoods_bounds ON neighborhoods USING GIST (bounds);\nCREATE INDEX IF NOT EXISTS idx_neighborhoods_city_state ON neighborhoods(city, state);\n\nCREATE INDEX IF NOT EXISTS idx_user_property_interactions_user_id ON user_property_interactions(user_id);\nCREATE INDEX IF NOT EXISTS idx_user_property_interactions_property_id ON user_property_interactions(property_id);\nCREATE INDEX IF NOT EXISTS idx_user_property_interactions_household_id ON user_property_interactions(household_id);\nCREATE INDEX IF NOT EXISTS idx_user_property_interactions_type ON user_property_interactions(interaction_type);\n\nCREATE INDEX IF NOT EXISTS idx_user_profiles_household_id ON user_profiles(household_id);\nCREATE INDEX IF NOT EXISTS idx_saved_searches_user_id ON saved_searches(user_id);\nCREATE INDEX IF NOT EXISTS idx_saved_searches_household_id ON saved_searches(household_id);""]",create_indexes,shankhayan.dutta@gmail.com,null
20250728013711,"[""-- Enable Row Level Security\nALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;\nALTER TABLE households ENABLE ROW LEVEL SECURITY;\nALTER TABLE neighborhoods ENABLE ROW LEVEL SECURITY;\nALTER TABLE properties ENABLE ROW LEVEL SECURITY;\nALTER TABLE user_property_interactions ENABLE ROW LEVEL SECURITY;\nALTER TABLE saved_searches ENABLE ROW LEVEL SECURITY;""]",enable_rls,shankhayan.dutta@gmail.com,null
20250728013721,"[""-- RLS Policies\n\n-- User profiles: Users can only access their own profile\nCREATE POLICY \""Users can view their own profile\"" ON user_profiles\n  FOR SELECT USING (auth.uid() = id);\n\nCREATE POLICY \""Users can update their own profile\"" ON user_profiles\n  FOR UPDATE USING (auth.uid() = id);\n\nCREATE POLICY \""Users can insert their own profile\"" ON user_profiles\n  FOR INSERT WITH CHECK (auth.uid() = id);\n\n-- Households: Users can access households they belong to\nCREATE POLICY \""Users can view their household\"" ON households\n  FOR SELECT USING (\n    id IN (\n      SELECT household_id FROM user_profiles \n      WHERE id = auth.uid()\n    )\n  );\n\nCREATE POLICY \""Users can update their household\"" ON households\n  FOR UPDATE USING (\n    id IN (\n      SELECT household_id FROM user_profiles \n      WHERE id = auth.uid()\n    )\n  );\n\n-- Neighborhoods: Public read access\nCREATE POLICY \""Anyone can view neighborhoods\"" ON neighborhoods\n  FOR SELECT USING (true);\n\n-- Properties: Public read access for active properties\nCREATE POLICY \""Anyone can view active properties\"" ON properties\n  FOR SELECT USING (is_active = true);\n\n-- User property interactions: Users can only access their own interactions\nCREATE POLICY \""Users can view their own interactions\"" ON user_property_interactions\n  FOR SELECT USING (auth.uid() = user_id);\n\nCREATE POLICY \""Users can insert their own interactions\"" ON user_property_interactions\n  FOR INSERT WITH CHECK (auth.uid() = user_id);\n\nCREATE POLICY \""Users can update their own interactions\"" ON user_property_interactions\n  FOR UPDATE USING (auth.uid() = user_id);\n\n-- Saved searches: Users can only access their own searches\nCREATE POLICY \""Users can view their own searches\"" ON saved_searches\n  FOR SELECT USING (auth.uid() = user_id);\n\nCREATE POLICY \""Users can insert their own searches\"" ON saved_searches\n  FOR INSERT WITH CHECK (auth.uid() = user_id);\n\nCREATE POLICY \""Users can update their own searches\"" ON saved_searches\n  FOR UPDATE USING (auth.uid() = user_id);\n\nCREATE POLICY \""Users can delete their own searches\"" ON saved_searches\n  FOR DELETE USING (auth.uid() = user_id);""]",create_rls_policies,shankhayan.dutta@gmail.com,null
20250804053305,"[""-- Migration: 20250801213500_create_interaction_summary_fn.sql\n-- This function aggregates interaction counts for a given user and is used by GET /api/interactions?type=summary\n\n-- Ensure schema exists\nCREATE SCHEMA IF NOT EXISTS public;\n\n-- Create or replace function\nCREATE OR REPLACE FUNCTION public.get_user_interaction_summary(p_user_id UUID)\nRETURNS TABLE(interaction_type TEXT, count BIGINT)\nLANGUAGE sql\nSTABLE\nAS $$\n  SELECT interaction_type, COUNT(*)::bigint AS count\n  FROM public.user_property_interactions\n  WHERE user_id = p_user_id\n  GROUP BY interaction_type\n  ORDER BY interaction_type\n$$;\n\n-- Grant execution rights to authenticated role\nGRANT EXECUTE ON FUNCTION public.get_user_interaction_summary(UUID) TO authenticated;\n\n-- Optional comments for documentation\nCOMMENT ON FUNCTION public.get_user_interaction_summary(UUID) IS 'Aggregates interaction counts by type for the specified user_id.';\n""]",create_interaction_summary_fn,shankhayan.dutta@gmail.com,null
20250730080325,"[""-- SAFE PostGIS geometry migration for neighborhoods bounds column\n-- Using ST_MakePolygon with proper conversion\n\nDO $$\nDECLARE\n    has_postgis_extension BOOLEAN;\n    has_polygon_data BOOLEAN;\n    column_type TEXT;\nBEGIN\n    -- Check if PostGIS is installed\n    SELECT EXISTS (\n        SELECT 1 FROM pg_extension WHERE extname = 'postgis'\n    ) INTO has_postgis_extension;\n    \n    IF NOT has_postgis_extension THEN\n        RAISE EXCEPTION 'PostGIS extension is not installed. Please install it first.';\n    END IF;\n    \n    -- Check current column type\n    SELECT data_type INTO column_type\n    FROM information_schema.columns\n    WHERE table_schema = 'public' \n      AND table_name = 'neighborhoods' \n      AND column_name = 'bounds';\n    \n    -- If already using geometry type, skip migration\n    IF column_type = 'USER-DEFINED' THEN\n        -- Check if it's already the correct geometry type\n        IF EXISTS (\n            SELECT 1 \n            FROM geometry_columns \n            WHERE f_table_schema = 'public' \n              AND f_table_name = 'neighborhoods' \n              AND f_geometry_column = 'bounds'\n              AND type = 'POLYGON'\n              AND srid = 4326\n        ) THEN\n            RAISE NOTICE 'Column already uses correct PostGIS geometry type. Skipping migration.';\n            RETURN;\n        END IF;\n    END IF;\n    \n    -- Check if we have data to preserve\n    SELECT EXISTS (\n        SELECT 1 FROM neighborhoods WHERE bounds IS NOT NULL\n    ) INTO has_polygon_data;\n    \n    IF has_polygon_data THEN\n        RAISE NOTICE 'Found existing polygon data. Creating backup and converting...';\n        \n        -- Create backup column\n        ALTER TABLE neighborhoods \n        ADD COLUMN IF NOT EXISTS bounds_backup polygon;\n        \n        -- Copy existing data to backup\n        UPDATE neighborhoods \n        SET bounds_backup = bounds\n        WHERE bounds IS NOT NULL;\n        \n        -- Add new PostGIS column\n        ALTER TABLE neighborhoods \n        ADD COLUMN IF NOT EXISTS bounds_new GEOMETRY(POLYGON, 4326);\n        \n        -- Convert polygon to PostGIS using ST_MakePolygon\n        -- First convert to path (linestring), then to polygon\n        UPDATE neighborhoods \n        SET bounds_new = ST_SetSRID(\n            ST_MakePolygon(\n                bounds::path::geometry\n            ), \n            4326\n        )\n        WHERE bounds IS NOT NULL;\n        \n        -- Drop old column and rename new one\n        ALTER TABLE neighborhoods DROP COLUMN bounds;\n        ALTER TABLE neighborhoods RENAME COLUMN bounds_new TO bounds;\n        \n        RAISE NOTICE 'Data conversion complete. Backup stored in bounds_backup column.';\n    ELSE\n        RAISE NOTICE 'No existing polygon data found. Safe to recreate column.';\n        \n        -- Simply drop and recreate if no data\n        ALTER TABLE neighborhoods DROP COLUMN IF EXISTS bounds;\n        ALTER TABLE neighborhoods ADD COLUMN bounds GEOMETRY(POLYGON, 4326);\n    END IF;\n    \n    -- Create spatial index\n    CREATE INDEX IF NOT EXISTS idx_neighborhoods_bounds \n    ON neighborhoods USING GIST(bounds);\n    \n    -- Add documentation\n    COMMENT ON COLUMN neighborhoods.bounds IS \n    'PostGIS polygon geometry representing neighborhood boundaries in WGS84 (SRID 4326)';\n    \nEND $$;""]",fix_postgis_geometry_type_neighborhoods_v5,shankhayan.dutta@gmail.com,null
20250730080343,"[""-- SAFE PostGIS geometry migration for properties coordinates column\n-- This version preserves existing data by converting it\n\nDO $$\nDECLARE\n    has_postgis_extension BOOLEAN;\n    has_point_data BOOLEAN;\n    column_type TEXT;\nBEGIN\n    -- Check if PostGIS is installed\n    SELECT EXISTS (\n        SELECT 1 FROM pg_extension WHERE extname = 'postgis'\n    ) INTO has_postgis_extension;\n    \n    IF NOT has_postgis_extension THEN\n        RAISE EXCEPTION 'PostGIS extension is not installed. Please install it first.';\n    END IF;\n    \n    -- Check current column type\n    SELECT data_type INTO column_type\n    FROM information_schema.columns\n    WHERE table_schema = 'public' \n      AND table_name = 'properties' \n      AND column_name = 'coordinates';\n    \n    -- If already using geometry type, skip migration\n    IF column_type = 'USER-DEFINED' THEN\n        -- Check if it's already the correct geometry type\n        IF EXISTS (\n            SELECT 1 \n            FROM geometry_columns \n            WHERE f_table_schema = 'public' \n              AND f_table_name = 'properties' \n              AND f_geometry_column = 'coordinates'\n              AND type = 'POINT'\n              AND srid = 4326\n        ) THEN\n            RAISE NOTICE 'Column already uses correct PostGIS geometry type. Skipping migration.';\n            RETURN;\n        END IF;\n    END IF;\n    \n    -- Check if we have data to preserve\n    SELECT EXISTS (\n        SELECT 1 FROM properties WHERE coordinates IS NOT NULL\n    ) INTO has_point_data;\n    \n    IF has_point_data THEN\n        RAISE NOTICE 'Found existing point data. Creating backup and converting...';\n        \n        -- Create backup column\n        ALTER TABLE properties \n        ADD COLUMN IF NOT EXISTS coordinates_backup point;\n        \n        -- Copy existing data to backup\n        UPDATE properties \n        SET coordinates_backup = coordinates\n        WHERE coordinates IS NOT NULL;\n        \n        -- Add new PostGIS column\n        ALTER TABLE properties \n        ADD COLUMN IF NOT EXISTS coordinates_new GEOMETRY(POINT, 4326);\n        \n        -- Convert point data to PostGIS\n        -- PostgreSQL point format: (x,y) = (longitude,latitude)\n        UPDATE properties \n        SET coordinates_new = ST_SetSRID(\n            ST_MakePoint(\n                (coordinates[0])::double precision,  -- longitude\n                (coordinates[1])::double precision   -- latitude\n            ), \n            4326\n        )\n        WHERE coordinates IS NOT NULL;\n        \n        -- Drop old column and rename new one\n        ALTER TABLE properties DROP COLUMN coordinates;\n        ALTER TABLE properties RENAME COLUMN coordinates_new TO coordinates;\n        \n        RAISE NOTICE 'Data conversion complete. Backup stored in coordinates_backup column.';\n    ELSE\n        RAISE NOTICE 'No existing point data found. Safe to recreate column.';\n        \n        -- Simply drop and recreate if no data\n        ALTER TABLE properties DROP COLUMN IF EXISTS coordinates;\n        ALTER TABLE properties ADD COLUMN coordinates GEOMETRY(POINT, 4326);\n    END IF;\n    \n    -- Create spatial index\n    CREATE INDEX IF NOT EXISTS idx_properties_coordinates \n    ON properties USING GIST(coordinates);\n    \n    -- Add documentation\n    COMMENT ON COLUMN properties.coordinates IS \n    'PostGIS point geometry representing property location in WGS84 (SRID 4326)';\n    \nEND $$;""]",fix_postgis_geometry_type_properties,shankhayan.dutta@gmail.com,null
20250730080404,"[""-- Create a trigger to automatically create user profiles when users sign up\nCREATE OR REPLACE FUNCTION public.handle_new_user()\nRETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO public.user_profiles (id, onboarding_completed, preferences)\n  VALUES (NEW.id, false, '{}'::jsonb);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Drop existing trigger if it exists\nDROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;\n\n-- Create the trigger\nCREATE TRIGGER on_auth_user_created\n  AFTER INSERT ON auth.users\n  FOR EACH ROW\n  EXECUTE FUNCTION public.handle_new_user();""]",add_user_profile_trigger,shankhayan.dutta@gmail.com,null
20250730080518,"[""-- Create RPC function for geographic property search\n-- Fixed version that matches production schema\n\nCREATE OR REPLACE FUNCTION get_properties_within_radius(\n  center_lat DOUBLE PRECISION,\n  center_lng DOUBLE PRECISION,\n  radius_km DOUBLE PRECISION\n)\nRETURNS TABLE (\n  id UUID,\n  address TEXT,\n  city TEXT,\n  state TEXT,\n  zip_code TEXT,\n  price INTEGER,\n  bedrooms INTEGER,\n  bathrooms NUMERIC,\n  square_feet INTEGER,\n  property_type TEXT,\n  listing_status TEXT,\n  coordinates GEOMETRY(POINT, 4326),\n  neighborhood_id UUID,\n  property_hash TEXT,\n  is_active BOOLEAN,\n  created_at TIMESTAMPTZ,\n  updated_at TIMESTAMPTZ,\n  -- Additional computed fields\n  neighborhood_name TEXT,\n  distance_km DOUBLE PRECISION\n) \nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $$\nBEGIN\n  RETURN QUERY\n  SELECT \n    p.id,\n    p.address,\n    p.city,\n    p.state,\n    p.zip_code,\n    p.price,\n    p.bedrooms,\n    p.bathrooms,\n    p.square_feet,\n    p.property_type,\n    p.listing_status,\n    p.coordinates,\n    p.neighborhood_id,\n    p.property_hash,\n    p.is_active,\n    p.created_at,\n    p.updated_at,\n    n.name as neighborhood_name,\n    ST_Distance(\n      p.coordinates::geography, \n      ST_SetSRID(ST_Point(center_lng, center_lat), 4326)::geography\n    ) / 1000.0 as distance_km\n  FROM properties p\n  LEFT JOIN neighborhoods n ON p.neighborhood_id = n.id\n  WHERE ST_DWithin(\n    p.coordinates::geography,\n    ST_SetSRID(ST_Point(center_lng, center_lat), 4326)::geography,\n    radius_km * 1000 -- Convert km to meters\n  )\n  AND p.is_active = true\n  ORDER BY distance_km ASC;\nEND;\n$$;\n\n-- Add spatial index for better performance\nCREATE INDEX IF NOT EXISTS idx_properties_coordinates_geography \n  ON properties USING GIST((coordinates::geography));\n\n-- Grant execute permission to authenticated users\nGRANT EXECUTE ON FUNCTION get_properties_within_radius TO authenticated;\n\n-- Add comment for documentation\nCOMMENT ON FUNCTION get_properties_within_radius IS \n  'Returns all active properties within a given radius (in kilometers) from a center point, ordered by distance. Used for geographic property searches.';""]",add_geographic_search_function_fixed,shankhayan.dutta@gmail.com,null
20250731041925,"[""-- Add CASCADE delete to user_profiles foreign key\n-- This ensures test users can be completely cleaned up\n\n-- Drop the existing foreign key constraint\nALTER TABLE public.user_profiles \nDROP CONSTRAINT IF EXISTS user_profiles_id_fkey;\n\n-- Re-add the foreign key with CASCADE delete\nALTER TABLE public.user_profiles\nADD CONSTRAINT user_profiles_id_fkey \nFOREIGN KEY (id) \nREFERENCES auth.users(id) \nON DELETE CASCADE;\n\n-- Also add CASCADE to other user-related tables that actually exist\n-- User property interactions (the actual table name)\nALTER TABLE public.user_property_interactions\nDROP CONSTRAINT IF EXISTS user_property_interactions_user_id_fkey;\n\nALTER TABLE public.user_property_interactions\nADD CONSTRAINT user_property_interactions_user_id_fkey\nFOREIGN KEY (user_id)\nREFERENCES auth.users(id)\nON DELETE CASCADE;\n\n-- Saved searches\nALTER TABLE public.saved_searches\nDROP CONSTRAINT IF EXISTS saved_searches_user_id_fkey;\n\nALTER TABLE public.saved_searches\nADD CONSTRAINT saved_searches_user_id_fkey\nFOREIGN KEY (user_id)\nREFERENCES auth.users(id)\nON DELETE CASCADE;\n\n-- Add a comment to document this change\nCOMMENT ON CONSTRAINT user_profiles_id_fkey ON public.user_profiles IS 'Foreign key to auth.users with CASCADE delete for proper test cleanup';""]",add_cascade_delete_to_user_profiles,shankhayan.dutta@gmail.com,null
20250801052809,"[""-- Migration: Enable anon read policy for marketing properties\n-- Created at: 2025-07-31 05:23:00 UTC\n\nbegin;\n\n-- Ensure RLS is enabled (safe if already enabled)\nalter table if exists public.properties enable row level security;\n\n-- Create or replace policy to allow anon SELECT of active listings for marketing\ndo $$\nbegin\n  if not exists (\n    select 1\n    from pg_policies\n    where schemaname = 'public'\n      and tablename = 'properties'\n      and policyname = 'properties_anon_marketing_read'\n  ) then\n    create policy properties_anon_marketing_read\n    on public.properties\n    for select\n    to anon\n    using (\n      listing_status = 'active'\n      and coalesce(is_active, true) = true\n    );\n  end if;\nend\n$$;\n\ncommit;""]",enable_marketing_read_policy,shankhayan.dutta@gmail.com,null
20250804053950,"[""-- Migration: harden_function_search_path (timestamped by server on apply)\n-- Purpose: Harden search_path and schema-qualify references for key functions flagged by Supabase Advisor.\n\n-- 1) get_user_interaction_summary\nCREATE OR REPLACE FUNCTION public.get_user_interaction_summary(p_user_id uuid)\nRETURNS TABLE(interaction_type text, count bigint)\nLANGUAGE sql\nSTABLE\nSET search_path = pg_catalog, public\nAS $$\n  SELECT interaction_type, COUNT(*)::bigint AS count\n  FROM public.user_property_interactions\n  WHERE user_id = p_user_id\n  GROUP BY interaction_type\n  ORDER BY interaction_type\n$$;\n\nGRANT EXECUTE ON FUNCTION public.get_user_interaction_summary(uuid) TO authenticated;\n\nCOMMENT ON FUNCTION public.get_user_interaction_summary(uuid)\nIS 'Aggregates interaction counts by type for the specified user_id. search_path hardened to pg_catalog, public.';\n\n-- 2) handle_new_user (trigger function)\nCREATE OR REPLACE FUNCTION public.handle_new_user()\nRETURNS trigger\nLANGUAGE plpgsql\nVOLATILE\nSET search_path = pg_catalog, public\nAS $$\nBEGIN\n  INSERT INTO public.user_profiles(id)\n  VALUES (NEW.id)\n  ON CONFLICT (id) DO NOTHING;\n  RETURN NEW;\nEND\n$$;\n\n-- Recreate trigger defensively to ensure it targets updated function\nDROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;\nCREATE TRIGGER on_auth_user_created\n  AFTER INSERT ON auth.users\n  FOR EACH ROW\n  EXECUTE FUNCTION public.handle_new_user();\n\nCOMMENT ON FUNCTION public.handle_new_user()\nIS 'Creates a user_profiles row upon new auth.users insert. search_path hardened to pg_catalog, public.';\n\n-- 3) get_properties_within_radius\nCREATE OR REPLACE FUNCTION public.get_properties_within_radius(\n  center_lat double precision,\n  center_lng double precision,\n  radius_meters integer\n)\nRETURNS SETOF public.properties\nLANGUAGE sql\nSTABLE\nSET search_path = pg_catalog, public\nAS $$\n  SELECT p.*\n  FROM public.properties AS p\n  WHERE p.coordinates IS NOT NULL\n    AND ST_DWithin(\n      p.coordinates::geography,\n      ST_SetSRID(ST_MakePoint(center_lng, center_lat), 4326)::geography,\n      radius_meters\n    )\n$$;\n\nGRANT EXECUTE ON FUNCTION public.get_properties_within_radius(double precision, double precision, integer) TO authenticated;\n\nCOMMENT ON FUNCTION public.get_properties_within_radius(double precision, double precision, integer)\nIS 'Find properties within a radius using PostGIS. search_path hardened to pg_catalog, public. Returns SETOF public.properties.';\n""]",harden_function_search_path,shankhayan.dutta@gmail.com,null
20250816045943,"[""-- Create optimized database functions for couples features\n\n-- Function to get mutual likes for a household efficiently\nCREATE OR REPLACE FUNCTION get_household_mutual_likes(p_household_id UUID)\nRETURNS TABLE (\n  property_id UUID,\n  liked_by_count BIGINT,\n  first_liked_at TIMESTAMPTZ,\n  last_liked_at TIMESTAMPTZ,\n  user_ids UUID[]\n)\nLANGUAGE SQL\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\n  SELECT \n    upi.property_id,\n    COUNT(DISTINCT upi.user_id) as liked_by_count,\n    MIN(upi.created_at) as first_liked_at,\n    MAX(upi.created_at) as last_liked_at,\n    ARRAY_AGG(DISTINCT upi.user_id) as user_ids\n  FROM public.user_property_interactions upi\n  WHERE \n    upi.household_id = p_household_id\n    AND upi.interaction_type = 'like'\n  GROUP BY upi.property_id\n  HAVING COUNT(DISTINCT upi.user_id) >= 2\n  ORDER BY MAX(upi.created_at) DESC;\n$$;\n\n-- Function to get household activity with enhanced performance\nCREATE OR REPLACE FUNCTION get_household_activity_enhanced(\n  p_household_id UUID,\n  p_limit INT DEFAULT 20,\n  p_offset INT DEFAULT 0\n)\nRETURNS TABLE (\n  id UUID,\n  user_id UUID,\n  property_id UUID,\n  interaction_type TEXT,\n  created_at TIMESTAMPTZ,\n  user_display_name TEXT,\n  user_email TEXT,\n  property_address TEXT,\n  property_price NUMERIC,\n  property_bedrooms INT,\n  property_bathrooms NUMERIC,\n  property_images TEXT[]\n)\nLANGUAGE SQL\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\n  SELECT \n    upi.id,\n    upi.user_id,\n    upi.property_id,\n    upi.interaction_type,\n    upi.created_at,\n    COALESCE(au.raw_user_meta_data->>'display_name', au.email) as user_display_name,\n    au.email as user_email,\n    p.address as property_address,\n    p.price as property_price,\n    p.bedrooms as property_bedrooms,\n    p.bathrooms as property_bathrooms,\n    p.images as property_images\n  FROM public.user_property_interactions upi\n  INNER JOIN public.user_profiles up ON upi.user_id = up.id\n  INNER JOIN auth.users au ON upi.user_id = au.id\n  INNER JOIN public.properties p ON upi.property_id = p.id\n  WHERE upi.household_id = p_household_id\n  ORDER BY upi.created_at DESC\n  LIMIT p_limit\n  OFFSET p_offset;\n$$;\n\n-- Function to check if a potential like would create a mutual like\nCREATE OR REPLACE FUNCTION check_potential_mutual_like(\n  p_user_id UUID,\n  p_property_id UUID,\n  p_household_id UUID\n)\nRETURNS TABLE (\n  would_be_mutual BOOLEAN,\n  partner_user_id UUID\n)\nLANGUAGE SQL\nSTABLE\nSECURITY DEFINER\nSET search_path = public\nAS $$\n  SELECT \n    CASE WHEN COUNT(*) > 0 THEN TRUE ELSE FALSE END as would_be_mutual,\n    (ARRAY_AGG(upi.user_id))[1] as partner_user_id\n  FROM public.user_property_interactions upi\n  WHERE \n    upi.household_id = p_household_id\n    AND upi.property_id = p_property_id\n    AND upi.interaction_type = 'like'\n    AND upi.user_id != p_user_id;\n$$;\n\n-- Add composite indexes for better performance\nCREATE INDEX IF NOT EXISTS idx_user_property_interactions_household_type_created \nON user_property_interactions(household_id, interaction_type, created_at DESC);\n\nCREATE INDEX IF NOT EXISTS idx_user_property_interactions_household_property_type \nON user_property_interactions(household_id, property_id, interaction_type);\n\nCREATE INDEX IF NOT EXISTS idx_user_property_interactions_household_user_type \nON user_property_interactions(household_id, user_id, interaction_type);\n\n-- Add RLS policies for the new functions\nCREATE POLICY \""Household members can access mutual likes function\"" ON user_property_interactions\nFOR SELECT\nUSING (\n  household_id IN (\n    SELECT household_id \n    FROM user_profiles \n    WHERE id = auth.uid()\n  )\n);\n\n-- Grant execute permissions to authenticated users\nGRANT EXECUTE ON FUNCTION get_household_mutual_likes(UUID) TO authenticated;\nGRANT EXECUTE ON FUNCTION get_household_activity_enhanced(UUID, INT, INT) TO authenticated;\nGRANT EXECUTE ON FUNCTION check_potential_mutual_like(UUID, UUID, UUID) TO authenticated;""]",create_couples_optimization_functions,shankhayan.dutta@gmail.com,null